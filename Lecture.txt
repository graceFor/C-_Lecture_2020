// Day_1
// assign_fun.c
#include <stdio.h>

void assign(int *x, int y)
{
    *x = y;
}
int main()
{
    int a = 0, b = 999;
    assign(&a, b);
    printf("%d\n", a);
    return 0;
}

//pswap.c
#include <stdio.h>

void pswap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main()
{
    int one, two;
    printf("one과 two의 값을 입력하시오: ");
    scanf("%d %d", &one, &two);
    pswap(&one, &two);
    printf("%d %d", one, two);
}

//포인터를 배열처럼 사용하기
#include <stdio.h>

int main()
{
    char str[6] = "hello";
    char *p;

    p = str;

    printf("%s\n", str);        // hello
    printf("%s\n", p);          // hello
    printf("%c\n", str[1]);     // e
    printf("%c\n", p[1]);       // e
    printf("%c\n", *(str + 1)); // e
    printf("%c\n", *(p + 1));   // e
}

//포인터를 배열처럼 사용하기
#include <stdio.h>

int main()
{
    char name[20] = "Jessie Norman";
    char *first;

    first = &name[7];      // Norman
    first[1] = 'a';        // Narman
    printf("%s\n", first); // Narman
    return 0;
}

//str_ptr.c
#include <stdio.h>

int main()
{
    char *str = "abcdefg";
    printf("%c\n", *str);
    printf("%s\n", str);

    str++;
    printf("%c\n", *str);
    printf("%s\n", str);

    str += 2;
    printf("%c\n", *str);
    printf("%s\n", str);
    return 0;
}

//str_ptr2.c => world만 출력되도록 하기
#include <stdio.h>

int main()
{
    char *str = "Hello world";

    str += 6;

    printf("%s\n", str);
    return 0;
}

// string copy program
#include <stdio.h>
void stringcopy(char *dest, char *src)
{

    for (src; *src; src++, dest++)
    {
        *dest = *src;
    }
    *dest = 0;
}
int main()
{
    char array1[20];
    char array2[20];
    scanf("%s", array1);
    stringcopy(array2, array1);
    printf("%s\n", array2);
    return 0;
}

// ref.cpp
#include <stdio.h>

void fun(int &b)
{
    b = 99;
}
int main()
{
    int a = 1;
    fun(a);
    printf("%d\n", a);
}

// return_ref.cpp
#include <stdlib.h>
#include <stdio.h>

int &makeInt(int val)
{
    int *p;
    p = (int *)malloc(sizeof(int));
    *p = val;
    return *p;
}
int main()
{
    int &a = makeInt(3);
    printf("%d\n", a);
}

// rswap.cpp
#include <stdio.h>

void rswap(int &x, int &y)
{
    int temp;
    temp = x;
    x = y;
    y = temp;
}

int main()
{
    int a = 0, b = 0;
    printf("a와 b의 값을 입력하시오 : ");
    scanf("%d %d", &a, &b);
    rswap(a, b);
    printf("%d %d\n", a, b);
}
// Day_2
// error.c
#include <stdlib.h>
#include <stdio.h>

int main()
{
    double *pDegree = NULL; // 포인터 초기화
    pDegree = (double *)malloc(sizeof(double));
    *pDegree = 12.345;
    printf("%lf\n", *pDegree);
}

// strcpy.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char str1[] = "Hello World";
    char *s;
    s = str1;
    printf("%s\n", s);
    strcpy(str1, "Howdy!");
    printf("%s\n", s);
}

// strcpy.c => malloc
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char str1[] = "Hello World";
    char *s;
    s = str1;
    s = (char *)malloc(strlen(str1) + 1);
    strcpy(s, str1);
    printf("%s\n", s);
    strcpy(str1, "Howdy!");
    printf("%s\n", s);
    printf("%s\n", str1);
}

//pointer_array.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char *pp[4];

    pp[0] = (char *)malloc(strlen("Hello") + 1);
    strcpy(pp[0], "Hello");
    printf("%s\n", pp[0]);

    char buffer[80];
    printf("string 입력 : ");
    scanf("%s", buffer);
    pp[1] = (char *)malloc(strlen(buffer) + 1);
    strcpy(pp[1], buffer);
    printf("%s\n", pp[1]);

    return 0;
}

// ptrarray.c => 최근에 넣은 값부터 출력해라
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char buffer[80];
    char *strptr[3];

    for (int i = 0; i < 3; i++)
    {
        scanf("%s", buffer);
        strptr[i] = (char *)malloc(strlen(buffer) + 1);
        strcpy(strptr[i], buffer);
    }
    for (int i = 2; i >= 0; i--)
    {
        printf("%s\n", strptr[i]);
    }
}

//darray.c => 주어진 배열을 동적 배열로 바꾸기
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    //int array[5];
    int index;
    int size;
    printf("Size를 입력하세요 : ");
    scanf("%d", &size);
    int *array = NULL;
    array = (int *)malloc(size * sizeof(int));
    for (index = 0; index < size; index++)
    {
        array[index] = index;
    }
    for (index = size - 1; index >= 0; index--)
    {
        printf("%d\n", array[index]);
    }
}

//realloc. c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char *p;
    char q[20];

    p = (char *)malloc(sizeof(char) * 10);
    printf("string 입력 : ");
    scanf("%s", q);
    strcpy(p, q);

    printf("string 입력 : ");
    scanf("%s", q);

    if (strlen(p) + strlen(q) + 1 > 10)
    {
        p = realloc(p, strlen(p) + strlen(q) + 1);
    }
    strcat(p, q);
    printf("%s\n", p);
    return 0;
}

// Day_3

// alist.c
#include <stdio.h>

int main()
{
    int start = 2;
    int score[8] = {55, 22, 11, 66, 33, 88, 44, 77};
    int next[8] = {3, 4, 1, 7, 6, -1, 0, 5};

    for (int i = start; i >= 0; i = next[i])
    {
        printf("%d\n", score[i]);
    }
    return 0;
}

//list1.c
#include <stdio.h>

struct item
{
    int score;
    struct item *next;
};

int main()
{
    struct item A, B;
    struct item *first;
    first = &A;
    A.score = 1;
    A.next = &B;
    B.score = 2;
    B.next = NULL;
    printf("%d\n", first->score);       //A의 score -> 1 출력
    printf("%d\n", A.score);            //A의 score -> 1 출력
    printf("%d\n", first->next->score); //B의 score -> 2 출력
    printf("%d\n", B.score);            //B의 score -> 2 출력
    printf("%d\n", (*(A.next)).score);  //B의 score -> 2 출력
    return 0;
}

//list2.c => 중간에 C 추가
#include <stdio.h>

struct item
{
    int score;
    struct item *next;
};

int main()
{
    struct item A, B, C;
    struct item *first;
    first = &A;
    A.score = 1;
    A.next = &B;
    B.score = 2;
    B.next = NULL;

    C.score = 3;
    C.next = &A;
    first = &C;

    printf("%d\n", first->score);             //C의 score -> 3 출력
    printf("%d\n", first->next->score);       //A의 score -> 1 출력
    printf("%d\n", first->next->next->score); //B의 score -> 2 출력

    return 0;
}

//list4.c
#include <stdio.h>

struct item
{
    int score;
    struct item *next;
};

int main()
{
    struct item A, B, C, D;
    struct item *pFirst;
    struct item *p;
    A.score = 1;
    B.score = 2;
    C.score = 3;
    D.score = 4;
    pFirst = &A;
    A.next = &B;
    B.next = &C;
    C.next = &D;
    D.next = NULL;
    p = pFirst;
    printf("%d-->", p->score); //A의 score -> 1
    p = p->next;
    printf("%d-->", p->score); //B의 score ->2
    p = p->next;
    printf("%d-->", p->score); //C의 score ->3
    p = p->next;
    printf("%d-->", p->score); //D의 score ->4

    printf("END\n");
    return 0;
}

//list5.c => 반복문을 이용해서 출력하기
#include <stdio.h>

struct item
{
    int score;
    struct item *next;
};

int main()
{
    struct item A, B, C, D;
    struct item *pFirst;
    struct item *p;
    A.score = 1;
    B.score = 2;
    C.score = 3;
    D.score = 4;
    pFirst = &A;
    A.next = &B;
    B.next = &C;
    C.next = &D;
    D.next = NULL;

    for (p = pFirst; p != NULL; p = p->next)
    {
        printf("%d-->", p->score);
    }
    printf("END\n");
    return 0;
}

//dlink.c => insert

#include <stdio.h>
#include <stdlib.h>

struct item
{
    int score;
    struct item *next;
};
struct item *p;
struct item *pFirst = NULL;

int main()
{
    p = (struct item *)malloc(sizeof(struct item));
    p->score = 33;
    p->next = pFirst;
    pFirst = p;

    p = (struct item *)malloc(sizeof(struct item));
    p->score = 22;
    p->next = pFirst;
    pFirst = p;

    p = (struct item *)malloc(sizeof(struct item));
    p->score = 11;
    p->next = pFirst;
    pFirst = p;

    printf("%d\n", pFirst->score);             //11
    printf("%d\n", pFirst->next->score);       //22
    printf("%d\n", pFirst->next->next->score); //33

    return 0;
}

//stack을 전역변수를 이용해서 만들기
#include <stdio.h>
#include <stdlib.h>

struct item
{
    int score;
    struct item *next;
};
struct item *pStack; // stack pointer

void insert(int n)
{
    struct item *pAlloc;
    pAlloc = (struct item *)malloc(sizeof(struct item));
    pAlloc->score = n;
    pAlloc->next = pStack;
    pStack = pAlloc;
}

int top()
{
    return pStack->score;
}
void pop()
{
    struct item *pFree;
    pFree = pStack; //삭제할 item 가르키기
    pStack = pStack->next;
    free(pFree);
}

int main()
{
    pStack = NULL;
    insert(1);
    insert(2);
    insert(3);

    printf("Stack top is %d\n", top()); // 3
    pop();
    printf("Stack top is %d\n", top()); // 2
    pop();
    printf("Stack top is %d\n", top()); // 1

    return 0;
}

//stack을 local 변수를 이용해서 만들기
#include <stdio.h>
#include <stdlib.h>

struct item
{
    int score;
    struct item *next;
};

void insert(struct item **s, int n)
{
    struct item *pAlloc;
    pAlloc = (struct item *)malloc(sizeof(struct item));
    pAlloc->score = n;
    pAlloc->next = *s;
    *s = pAlloc;
}

int top(struct item *s)
{
    return s->score;
}
void pop(struct item **s)
{
    struct item *pFree;
    pFree = *s; //삭제할 item 가르키기
    *s = (*s)->next;
    free(pFree);
}

int main()
{
    struct item *pStack = NULL; // stack pointer
    insert(&pStack, 1);
    insert(&pStack, 2);
    insert(&pStack, 3);

    printf("Stack top is %d\n", top(pStack)); // 3
    pop(&pStack);
    printf("Stack top is %d\n", top(pStack)); // 2
    pop(&pStack);
    printf("Stack top is %d\n", top(pStack)); // 1

    return 0;
}

//stack을 local 변수를 이용해서 만들기 => print_stack
#include <stdio.h>
#include <stdlib.h>

struct item
{
    int score;
    struct item *next;
};

void insert(struct item **s, int n)
{
    struct item *pAlloc;
    pAlloc = (struct item *)malloc(sizeof(struct item));
    pAlloc->score = n;
    pAlloc->next = *s;
    *s = pAlloc;
}

int top(struct item *s)
{
    return s->score;
}
void pop(struct item **s)
{
    struct item *pFree;
    pFree = *s; //삭제할 item 가르키기
    *s = (*s)->next;
    free(pFree);
}

void print_stack(struct item *pS)
{
    printf("TOP: ");
    for (; pS; pS = pS->next)
    {
        printf("%d --> ", pS->score);
    }
    printf("END\n");
}
int main()
{
    struct item *pStack = NULL; // stack pointer
    insert(&pStack, 1);
    insert(&pStack, 2);
    insert(&pStack, 3);

    print_stack(pStack);
    pop(&pStack);
    print_stack(pStack);
    pop(&pStack);
    print_stack(pStack);
    pop(&pStack);
    print_stack(pStack);

    return 0;
}

// Day_4

//sin(x) 그래프
#include <math.h>
#include <stdio.h>
#define PI 3.142

int main()
{
    double x;
    printf("+---------------+--------------+\n");
    for (x = 0.0; x < 2 * PI; x += 0.3)
    {
        int position;
        double y;
        y = sin(x);
        position = (int)(20.0 * y + 21.5);
        for (; position > 0; position--)
            putchar(' ');
        putchar('*');
        putchar('\n');
    }
    return 0;
}

// function_pointer에 함수 assign하기
#include <stdio.h>

void pretty_print(int val)
{
    printf("결과는 %d입니다.\n", val);
}
void simple_print(int val) { printf("%d\n", val); }

int main()
{
    void (*print)(int x);
    print = pretty_print;
    print(123);
    print = simple_print;
    print(125);

    return 0;
}

//fptest.c => 두 수를 더하는 함수 add, 두 수를 곱하는 함수 times
#include <stdio.h>

int plus(int x, int y) { return x + y; }
int times(int x, int y) { return x * y; }
int main()
{
    int (*fun)(int, int);
    fun = plus;
    printf("%d\n", fun(2, 3));
    fun = times;
    printf("%d\n", fun(2, 3));

    return 0;
}

//funpar.c => 함수 자체를 파라메터로 넘기기
#include <math.h>
#include <stdio.h>
#define PI 3.142

void draw_graph(double (*fun)(double), double from, double to)
{
    double x;
    int i;
    printf("+--------------------+--------------------+\n");
    from = from * PI / 180;
    to = to * PI / 180;
    for (x = from; x <= to; x += 0.2)
    {
        int position;
        double y;
        y = fun(x);
        position = (int)(20.0 * y + 21.5);
        for (i = 0; i < 42; i++)
        {
            if (i == position)
                putchar('*');
            else if (i == 21)
                putchar('|');
            else
                putchar(' ');
        }
        putchar('\n');
    }
}

int main()
{
    printf("sin 함수 그래프입니다.\n");
    draw_graph(sin, 0, 360);
    printf("cos 함수 그래프입니다.\n");
    draw_graph(cos, 0, 360);

    return 0;
}

// typedef의 이용
#include <stdio.h>

typedef int DBLFUN(int, int);

int main()
{
    DBLFUN *ff();
    DBLFUN *fun;

    fun = ff();
    printf("A %p\n", fun);
    printf("B %p\n", ff());
    printf("%d\n", fun(2, 3));

    return 0;
}

int plus(int x, int y) { return x + y; }
DBLFUN *ff() { return &plus; }

// typedef의 이용
#include <stdio.h>

void prn()
{
    printf("연습\n");
}
struct kim
{
    int data;
    void (*fun)();
};

int main()
{
    struct kim a;
    a.fun = prn;
    a.fun();

    return 0;
}

// Day_5 (7장_추상화)

// C언어로 객체 만들기 1
#include <stdio.h>
typedef struct
{
    double re;
    double im;
} Complex;

void print_c(Complex a)
{
    printf("%2.1f+%2.1fi\n", a.re, a.im);
}

int main()
{
    Complex x = {1.1, 2.2}, y = {3.3, 4.4};

    print_c(x);
    print_c(y);

    return 0;
}

// C언어로 객체 만들기 2
#include <stdio.h>
#include <stdlib.h>

typedef struct
{
    double re;
    double im;
    void (*printfunc)(struct Complex *);
} Complex;

void print_c(Complex *a)
{
    printf("%2.1f+%2.1fi\n", a->re, a->im);
}

int main()
{

    Complex *cp;
    cp = (Complex *)malloc(sizeof(Complex));
    cp->printfunc = print_c;
    cp->re = 1.1;
    cp->im = 2.2;
    cp->printfunc(cp);

    return 0;
}

// C언어로 객체 만들기 3
#include <stdio.h>

typedef struct function_pointer
{
    int n;
    void (*f)(int n);
} Fp;

void print(int n)
{
    printf("Function Pointer Test %d\n", n);
}

int main()
{
    Fp a;
    Fp *p;
    p = &a;
    p->f = print;
    p->f(3);

    return 0;
}

// C언어로 객체 만들기 4

#include <stdio.h>
#include <stdlib.h>

typedef struct
{
    double re;
    double im;
    void (*printfunc)(struct Complex *);
} Complex;

void print_c(Complex *a)
{
    printf("%2.1f + %2.1fi\n", a->re, a->im);
}
Complex *new_complex(double r, double i)
{
    Complex *t;
    t = (Complex *)malloc(sizeof(Complex));
    t->re = r;
    t->im = i;
    t->printfunc = print_c;
    return t;
}

int main()
{
    Complex *c;
    c = new_complex(2.2, 3.3);
    c->printfunc(c);

    return 0;
}

// C언어로 객체 만들기 5 => shape.c
#include <stdio.h>
#include <stdlib.h>

typedef struct shape
{
    float width, height;
    float (*area)(struct shape *);
} shape;

float rect_area(struct shape *s)
{
    return s->width * s->height;
}

float tri_area(struct shape *s)
{
    return s->width * s->height * 0.5;
}

shape *new_triangle(float h, float w)
{

    shape *t = (shape *)malloc(sizeof(shape));
    t->height = h;
    t->width = w;
    t->area = tri_area;
    return t;
}

shape *new_rectangle(float h, float w)
{
    shape *r = (shape *)malloc(sizeof(shape));
    r->height = h;
    r->width = w;
    r->area = rect_area;
    return r;
}

int main()
{
    shape *tri, *rect;
    rect = new_rectangle(2.0, 4.0);
    tri = new_triangle(2.0, 4.0);
    printf("Rectangle Area = %lf\n", rect->area(rect));
    printf("Triangle Area = %lf\n", tri->area(tri));

    return 0;
}

// C언어로 객체 만들기 6 => mystring.c
#include <stdio.h>
#include <stdlib.h>

typedef struct mystring
{
    char *p;
    void (*show)(struct mystring *s);
} mystring;

void print(mystring *s)
{
    if (s->p == 0)
    {
        printf("String is not initialized\n");
    }
    else
    {
        printf("%s", s->p);
    }
}

mystring *new_string(char *s)
{

    mystring *temp = (mystring *)malloc(sizeof(mystring));
    temp->p = strdup(s);
    temp->show = print;
    return temp;
}
int main()
{
    mystring *str;
    str = new_string("Hello");
    str->show(str);
    free(str);
    return 0;
}

// Hello World 출력
#include <iostream>
#include <stdio.h>
using namespace std;

int main()
{
    int number;
    cout << "정수 1개를 입력하시오.";
    cin >> number;
    printf("Hello world\n");
    cout << number << "\n";
    return 0;
}

//ci and cout
#include <iostream>
#include <stdio.h>
using namespace std;

int main()
{
    int num;
    char c;
    double ratio;
    char s[20];
    cin >> num;
    cin >> c;
    cin >> ratio >> s;

    cout << num << endl;
    cout << c << endl;
    cout << ratio << s;

    if (cin >> num)
    {
        cout << "데이터 입력됨" << endl;
    }
    else
    {
        cout << "더이상 입력이 없습니다." << endl;
    }
    return 0;
}

//C++ String type
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{

    string s("Hello");
    string s2;

    s2 = " world";
    s = s + s2;
    s += "!!!";

    cout << s << endl;

    return 0;
}

// 예외처리
#include <iostream>
using namespace std;

#include <stdio.h>
char msg[] = "존재하지 않는 스트링입니다.";
void mystrprint(const char *s)
{
    if (s == 0)
        throw msg;
    else
        printf("스트링은: %s입니다.\n", s);
}

int main()
{
    const char *s1 = "Hello";
    char *s2 = 0;
    try
    {
        mystrprint(s1);
        mystrprint(s2);
    }
    catch (char *s)
    {
        printf("%s", s);
    }
    return 0;
}

// Bird.c
#include <iostream>
#include <stdio.h>

struct Bird
{
    char name[10];
    void fly() { printf("I can fly\n"); }
    void sing() { printf("La La La\n"); }
};

int main()
{
    Bird b;
    b.fly();
    b.sing();

    return 0;
}

// Day_6 (9장_class_Method)

//this를 이용하여 표현하기

#include <stdio.h>
#include <iostream>
using namespace std;

struct Bird
{
public:
    string name;
    void sing()
    {
        cout << "My name is " << this->name << endl;
    }
};

int main()
{
    Bird b, c;
    b.name = "Tweety";
    c.name = "Birdy";
    b.sing();
    c.sing();

    return 0;
}

//rect.app
#include <stdio.h>
#include <iostream>
using namespace std;

struct Rect
{
    int m_width;
    int m_height;
    int area() { return m_width * m_height; }
};

int main()
{
    Rect r;
    r.m_width = 5;
    r.m_height = 6;
    cout << "면적 " << r.area() << endl;

    return 0;
}

//rectangle.app
#include <stdio.h>
#include <iostream>
using namespace std;

class Rectangle
{
private:
    int m_height;

public:
    void setHeight(int h) { m_height = h; }
};

int main()
{
    Rectangle r;
    // r.m_height=1;
    r.setHeight(1);

    return 0;
}

// Banck Account
#include <stdio.h>
#include <iostream>
using namespace std;

class Bank_Account
{
private:
    string BA_number;
    string BA_name;
    int balance;

public:
    void Set_BA_nunmber(string num) { BA_number = num; }
    void Set_BA_name(string name) { BA_name = name; }
    void Set_Balance(int bal) { balance = bal; }
    void Desposit(int deposit) { this->balance += deposit; }
    void Withdraw(int with) { balance -= with; }
    void print()
    {
        cout << "계좌번호: " << BA_number << endl;
        cout << "이름: " << BA_name << endl;
        cout << "잔고: " << balance << endl;
    }
};

int main()
{
    Bank_Account kim;
    kim.Set_BA_nunmber("60162269");
    kim.Set_BA_name("김현경");
    kim.Set_Balance(1000);
    kim.Desposit(500);
    kim.Withdraw(300);
    kim.print();

    return 0;
}

//사각형을 나타내는 주어진 클래스 Rect를 동적으로 할당
#include <iostream>
#include <stdio.h>
using namespace std;

class Rect
{
public:
    int m_width;
    int m_height;
    void show()
    {
        cout << "면적 " << m_width * m_height << endl;
    }
};

int main()
{
    Rect *rect;
    rect = new Rect;
    rect->m_height = 6;
    rect->m_width = 5;
    rect->show();

    return 0;
}

//사각형을 나타내는 주어진 클래스 Rect를 동적으로 할당
#include <iostream>
#include <stdio.h>
using namespace std;

class Rect
{
public:
    int m_width;
    int m_height;
    Rect()
    {
        m_width = 5;
        m_height = 6;
    }
    void show()
    {
        cout << "면적 " << m_width * m_height << endl;
    }
};

int main()
{
    Rect *rect;
    rect = new Rect;
    rect->show();

    return 0;
}

// 클래스 변수
#include <iostream>
#include <stdio.h>
using namespace std;

class Card
{
public:
    static int num_instance;
    int m_data;
    Card()
    {
        num_instance++;
        m_data = 0;
    }
    void show()
    {
        cout << "일련번호 " << num_instance << endl;
    }
};
int Card::num_instance = 0;

int main()
{
    Card c1;
    c1.show();
    Card c2;
    c2.show();

    return 0;
}

// 생성자 호출
#include <iostream>
#include <stdio.h>
using namespace std;

class Card
{
public:
    static int num_instance;
    int m_data;
    Card()
    {
        cout << "생성자 호출 " << num_instance++ << endl;
        m_data = 0;
    }
    void show()
    {
        cout << "일련번호 " << num_instance << endl;
    }
};
int Card::num_instance = 0;

int main()
{
    Card c1;
    Card *pc;
    pc = 0;
    pc = new Card;

    return 0;
}

Day_7

// 조건을 설정하여 범위를 넘는 경우에는 변경하지 않고 그냥 return 하기
#include <iostream>
#include <stdio.h>
using namespace std;

class Card
{
public:
    int suit;
    int rank;
    bool faceUp;
    Card()
    {
        suit = 0;
        rank = 0;
    }
    int getSuit() { return suit; }
    int getRank() { return rank; }
    void setSuitRank(int s, int r)
    {
        if (s >= 0 && s <= 3)
        {
            suit = s;
        }
        if (r >= 0 && r <= 12)
        {
            rank = r;
        }
    }
    void flip() { faceUp = !faceUp; }
    void show() { cout << "Suit: " << suit << endl
                       << "Rank: " << rank << endl; }
};

int main()
{
    enum suit
    {
        spade,
        diamond,
        clover,
        heart
    };
    Card card1;
    card1.setSuitRank(clover, 11);
    card1.show();
    card1.setSuitRank(heart, 15);
    card1.show();
    card1.setSuitRank(4, 1);
    card1.show();

    return 0;
}

// 원형과 구현의 분리
#include <iostream>
#include <stdio.h>
using namespace std;

class Card
{
public:
    int suit;
    int rank;
    bool faceUp;
    Card()
    {
        suit = 0;
        rank = 0;
    }
    int getSuit() { return suit; }
    int getRank() { return rank; }
    void setSuitRank(int s, int r)
    {
        if (s >= 0 && s <= 3)
        {
            suit = s;
        }
        if (r >= 0 && r <= 12)
        {
            rank = r;
        }
    }
    void flip() { faceUp = !faceUp; }
    void show(); //원형만 남겨두고
};

void Card::show()
{ //구현은 여기서
    {
        cout << "Suit: " << suit << endl
             << "Rank: " << rank << endl;
    }
}
int main()
{
    enum suit
    {
        spade,
        diamond,
        clover,
        heart
    };
    Card card1;
    card1.setSuitRank(clover, 11);
    card1.show();
    card1.setSuitRank(heart, 15);
    card1.show();
    card1.setSuitRank(4, 1);
    card1.show();

    return 0;
}

// card.h
#ifndef __CARD_H
#define __CARD_H
class Card
{
public:
    int suit;
    int rank;
    bool faceUp;
    Card();
    int getSuit();
    int getRank();
    void setSuitRank(int s, int r);
    void flip();
    void show(); //원형만 남겨두고
};

#endif

//cardm.cpp
#include <iostream>
#include "card.h"
using namespace std;

Card::Card()
{
    suit = 0;
    rank = 0;
}
int Card::getSuit() { return suit; }
int Card::getRank() { return rank; }
void Card::setSuitRank(int s, int r)
{
    if (s >= 0 && s <= 3)
    {
        suit = s;
    }
    if (r >= 0 && r <= 12)
    {
        rank = r;
    }
}
void Card::flip() { faceUp = !faceUp; }
void Card::show()
{ //구현은 여기서
    {
        cout << "Suit: " << suit << endl
             << "Rank: " << rank << endl;
    }
}

// 원형과 구현의 분리
#include <stdio.h>
#include "card.h"

int main()
{
    enum suit
    {
        spade,
        diamond,
        clover,
        heart
    };
    Card card1;
    card1.setSuitRank(clover, 11);
    card1.show();
    card1.setSuitRank(heart, 15);
    card1.show();
    card1.setSuitRank(4, 1);
    card1.show();

    return 0;
}

// Dog.h

#ifndef __DOG_H
#define __DOG_H
#include <string>
using namespace std;
class DogSchool;

class Dog
{
public:
    string m_name;
    DogSchool *m_school;
    Dog(string n) : m_name(n), m_school(0) {}
    void bark();
    void setSchool(DogSchool *ds);
};
#endif

//DogSchool.h

#ifndef __DOGSCHOOL_H
#define __DOGSCHOOL_H
#include <string>
using namespace std;

class Dog;
class DogSchool
{
public:
    int numDogs;
    string m_shool_name;
    Dog *allDogs[100];
    DogSchool(string sname) : m_shool_name(sname), numDogs(0) {}
    string get_name();
    void insert(Dog *d);
};

#endif

// Dog.cpp

#include <iostream>
#include "Dog.h"
#include "DogSchool.h"

void Dog::bark()
{
    cout << "멍멍." << m_name << endl;
    if (m_school)
    {
        cout << "나는 " << m_school->get_name() << "에 다닙니다.\n";
    }
}
void Dog::setSchool(DogSchool *ds)
{
    {
        m_school = ds;
    }
}

// DogSchool.cpp

#include "Dog.h"
#include "DogSchool.h"

string DogSchool::get_name() { return m_shool_name; }
void DogSchool::insert(Dog *d)
{
    allDogs[numDogs++] = d;
    d->setSchool(this);
}

// girl.h

#ifndef __GIRL_H
#define __GIRL_H
#include <string>
#include <iostream>
using namespace std;

class Boy;

class Girl
{
public:
    string m_gname;
    Boy *m_boyfriend;
    Girl(string gname) : m_gname(gname), m_boyfriend(0) {}
    string get_gname();
    void hello();
    void SetBF(Boy *ds);
};

#endif

// boy.h

#ifndef __BOY_H
#define __BOY_H
#include <string>
#include <iostream>
using namespace std;

class Girl;

class Boy
{
public:
    string m_bname;
    Girl *m_girlfriend;
    Boy(string bname) : m_bname(bname), m_girlfriend(0) {}
    string get_bname();
    void hello();
    void SetGF(Girl *ds);
};

#endif

#include "girl.h"
#include "boy.h"
#include <iostream>
using namespace std;

string Girl::get_gname() { return m_gname; }
void Girl::hello()
{
    cout << "나는 " << m_gname << "입니다. \n";
    cout << "내 남자 친구는 " << m_boyfriend->get_bname()
         << "입니다. \n";
}
void Girl::SetBF(Boy *ds) { m_boyfriend = ds; }

#include "girl.h"
#include "boy.h"
#include <iostream>
using namespace std;

string Boy::get_bname() { return m_bname; }
void Boy::hello()
{
    cout << "나는 " << m_bname << "입니다. \n";
    cout << "내 여자 친구는 " << m_girlfriend->get_gname()
         << "입니다. \n";
}
void Boy::SetGF(Girl *ds) { m_girlfriend = ds; }

Day_8

//Bank_Account => 여러가지 생성자
#include <iostream>

using namespace std;

class BankAccout
{
public:
    BankAccout()
    {
        m_balance = 0;
        m_irate = 0.05;
    }
    BankAccout(int bal)
    {
        m_balance = bal;
        m_irate = 0.05;
    }
    BankAccout(double rate)
    {
        m_balance = 0;
        m_irate = rate;
    }
    void show()
    {
        cout << "잔액 " << m_balance << "\n이자율: " << m_irate << endl;
    }

private:
    int m_balance;
    double m_irate;
};

int main()
{
    BankAccout b1;
    b1.show();
    BankAccout b2 = BankAccout(100);
    b2.show();
    BankAccout b3 = BankAccout(0.1);
    b3.show();

    return 0;
}

//여러가지 생성자 만들기 

#include <iostream>

using namespace std;

class Rect
{
public:
    Rect()
    {
        width = 1;
        height = 1;
    }
    Rect(int r)
    {
        width = r;
        height = r;
    }
    Rect(int w, int h)
    {
        width = w;
        height = h;
    }
    void area()
    {
        cout << "면적 " << width << " * " << height << " = " << width * height << endl;
    }

private:
    int width, height;
};

int main()
{
    Rect *r1 = new Rect();
    r1->area();
    Rect *r2 = new Rect(2);
    r2->area();
    Rect *r3 = new Rect(3, 4);
    r3->area();

    return 0;
}

//no_delete.cpp

#include <iostream>
#include <string.h>

using namespace std;

class mystring
{
    char buffer[100 * 1024 * 1024];

public:
    void set(const char *s)
    {
        strcpy(buffer, s);
    }
};

int main()
{
    int i;
    for (i = 0; i < 100; i++)
    {
        mystring *str;
        str = new mystring;
        cout << i << endl;
        delete str;
    }
    cout << "정상 종료\n";
    return 0;
}

//Memory Leak one solution

#include <iostream>
#include <string.h>
#include <stdlib.h>

using namespace std;

class String
{
    char *m_data;

public:
    String(char *s)
    {
        m_data = (char *)malloc(strlen(s) + 1);
        strcpy(m_data, s);
    }
    ~String() { free(m_data); }
};
int main()
{
    String *p = new String("Hello");
    delete (p);

    return 0;
}

//배열일 때 생성자와 소멸자

#include <iostream>
#include <string.h>
#include <stdlib.h>

using namespace std;

class Dog
{
public:
    static int numDog;
    int mynum;
    Dog()
    {
        mynum = numDog++;
        cout << "Dog " << mynum << " is born.\n";
    }
    ~Dog() { cout << "dog" << mynum << "is dead.\n"; }
};
int Dog::numDog = 0;
int main()
{
    Dog *d = new Dog[5];
    delete[] d;
}

// Day_9

// Eight_Queen
#include <iostream>

using namespace std;

class queen
{
public:
    queen(int, queen *); // constructor

    // find and print solution
    bool findSolution();
    bool advance();
    void print();

private:
    int m_row;
    const int m_column;
    queen *m_neighbor;

    //internal method
    bool canAttack(int, int);
};

queen ::queen(int col, queen *ngh) : m_column(col), m_neighbor(ngh)
{
    m_row = 1;
}

void queen::print()
{
    queen *p;
    p = this;
    while (p != 0)
    {
        cout << p->m_column << " " << p->m_row
             << endl;
        p = p->m_neighbor;
    }
}

bool queen::canAttack(int testRow, int testColumn)
{
    // 행이 같은지 보자
    if (m_row == testRow)
        return true;
    // 대각선 테스트
    int columnDifference = testColumn - m_column;
    if ((m_row + columnDifference == testRow) ||
        (m_row - columnDifference == testRow))
        return true;
    // 옆의 퀸에게 물어보자
    return m_neighbor &&
           m_neighbor->canAttack(testRow, testColumn);
}

bool queen::findSolution()
{
    // neighbor 들의 위치와 충돌 여부 확인
    while (m_neighbor &&
           m_neighbor->canAttack(m_row, m_column))
    {
        bool result;
        result = advance();
        if (result == false)
        { // 더 갈 곳이 없음.
            return false;
        }
    }
    // 답을 찾은 경우:
    return true;
}

bool queen::advance() // 이동하고 check하기
{
    if (m_row < 8)
    {
        m_row++;
        return findSolution();
    }
    if (m_neighbor && // 더 이상 갈 곳이 없으므로 neighbor를
        m_neighbor->advance() == false)
    { // 이동시켜 해결책 찾기
        return false;
    }
    m_row = 1;
    return findSolution();
}

int main()
{
    queen *lastQueen = 0;
    for (int i = 1; i <= 8; i++)
    {
        lastQueen = new queen(i, lastQueen);
        if (lastQueen->findSolution() == false)
            cout << "no solution\n";
    }
    lastQueen->print();
}

//class Dog => parent, class Jindo => child (상속)

#include <iostream>

using namespace std;

class Dog
{
public:
    Dog(string n) : m_name(n) {}
    void show() { cout << "나는 " << m_name << "입니다." << endl; }

private:
    string m_name;
};

class Jindo : public Dog
{
public:
    Jindo(string n) : Dog(n) {}
};

int main()
{
    Dog d("치와와");
    d.show();
    Jindo j("진도개");
    j.show();
    return 0;
}

//FlyingDog (상속)

#include <iostream>

using namespace std;

class Dog
{
public:
    Dog(string n) : m_name(n) {}
    void show() { cout << "나는 " << m_name << "입니다." << endl; }

private:
    string m_name;
};

class FlyingDog : public Dog
{
public:
    FlyingDog(string n) : Dog(n) {}
    void fly()
    {
        cout << "훨훨\n";
    }
};

int main()
{
    FlyingDog d("플라이견");
    d.show();
    d.fly();
    return 0;
}

//noisyDog (상속 - overriding)

#include <iostream>

using namespace std;

class Dog
{
public:
    Dog(string n) : m_name(n) {}
    void show() { cout << "나는 " << m_name << "입니다." << endl; }
    void bark() { cout << "멍멍~" << endl; }

private:
    string m_name;
};

class noisyDog : public Dog
{
public:
    noisyDog(string n) : Dog(n) {}
    void bark()
    {
        Dog::bark();
        Dog::bark();
    }
};

int main()
{
    noisyDog d("시끄러운개");
    d.show();
    d.bark();
}

// Polygon에서 사각형, 직각사각형을 상속받아 나타내기

#include <iostream>
using namespace std;

class Polygon
{
protected:
    int m_width, m_height;

public:
    int area(){};
    void setsize(int w, int h)
    {
        m_width = w;
        m_height = h;
    }
};

class Rectangle : public Polygon
{
public:
    int area()
    {
        return m_width * m_height;
    }
};

class Triangel : public Polygon
{
public:
    int area()
    {
        return m_width * m_height / 2;
    }
};

int main()
{
    Rectangle r;
    Triangel t;
    r.setsize(3, 4);
    t.setsize(5, 10);
    int r_a = r.area();
    int t_a = t.area();
    cout << "사각형의 넓이 = " << r_a << endl;
    cout << "삼각형의 넓이 = " << t_a << endl;

    return 0;
}

// Day_10
// animal.cpp
#include <iostream>
using namespace std;

class Animal
{
public:
    Animal(string n) : a_name(n) {}
    void show() { cout << "Animal " << a_name << endl; }

protected:
    string a_name;
};

class Dog : public Animal
{
public:
    Dog(string n) : Animal(n) {}
};

int main()
{
    Animal *a = new Animal("동물");
    Dog *d = new Dog("개");
    a = d;
    a->show();
    d->show();
    return 0;
}

//method Binding in C++

#include <iostream>
using namespace std;

class Animal
{
public:
    virtual void monya() { cout << "동물" << endl; }
    void whatRU() { cout << "An animal!" << endl; }
};

class Dog : public Animal
{
public:
    virtual void monya() { cout << "멍멍이" << endl; }
    void whatRU() { cout << "A Dog!" << endl; }
};

int main()
{
    Animal *ap;
    Animal a2;
    Dog *fido = new Dog();
    Dog doggy;
    ap = fido;
    a2 = doggy;

    fido->monya();
    fido->whatRU();
    ap->monya();
    ap->whatRU();
    a2.monya();
    a2.whatRU();

    return 0;
}

//Dynamic_Binding

#include <iostream>
using namespace std;

class Figure
{
protected:
    float width, height;

public:
    Figure()
    {
        width = 0;
        height = 0;
    }
    Figure(float w, float h)
    {
        width = w;
        height = h;
    }
    void setsize(float w, float h)
    {
        width = w;
        height = h;
    }
    virtual float area() { return 1; }
};

class Triangle : public Figure
{
public:
    Triangle() : Figure() {}
    virtual float area() { return height * width * 0.5; }
};

class Rectangle : public Figure
{
public:
    Rectangle() : Figure() {}
    virtual float area() { return height * width; }
};

int main()
{
    Figure *all[2];
    int type;
    float width, height;
    cout << "타입과 너비, 높이를 입력하세요(0 삼각, 1 사각)";
    cin >> type >> width >> height;
    if (type == 0)
    {
        all[0] = new Triangle();
        all[0]->setsize(width, height);
        cout << "삼각형의 면적은 " << all[0]->area() << endl;
    }
    else
    {
        all[1] = new Rectangle();
        all[1]->setsize(width, height);
        cout << "사각형의 면적은 " << all[1]->area() << endl;
    }
    return 0;
}
//java_script

var x = "12";
var y = 12;
var z1 = 3;
var z2 = 3;
z1 = x + z1;
z2 = y + z2;
alert("Z1 is" + z1);
alert("Z2 is" + z2);

//void pointer
#include <iostream>
enum Type
{
    INT,
    FLOAT,
    STRING,
};
void Print(void *pValue, Type eType)
{
    using namespace std;
    switch (eType)
    {
    case INT:
        cout << *static_cast<int *>(pValue) << endl;
        break;
    case FLOAT:
        cout << *static_cast<float *>(pValue) << endl;
        break;
    case STRING:
        cout << static_cast<char *>(pValue) << endl;
        break;
    }
}

int main()
{
    int nValue = 5;
    float fValue = 7.5;
    char szValue[] = "Mollie";
    Print(&nValue, INT);
    Print(&fValue, FLOAT);
    Print(szValue, STRING);
    return 0;
}

//padak.cpp => 상속으로

#include <iostream>
#include <windows.h>
using namespace std;

class KyoChon
{
public:
    void make_chicken()
    {
        int n;
        cout << ＂닭을 기름에 넣는다. \n ";
                for (n = 5; n >= 1; n--)
        {
            cout << "닭을 " << n << "분간 더 튀깁니다. \n";
            Sleep(2000);
        }
        cout << "닭이 다 익었습니다. " << endl;
    }
};

class Padak : public KyoChon
{
public:
    void make_chicken()
    {
        KyoChon::make_chicken();
        cout << "파를 100그램 얹습니다." << endl;
    }
};

int main()
{
    Padak p1;
    p1.make_chicken();

    return 0;
} 

// padak_2.cpp => 포함을 이용해서

#include <iostream>
using namespace std;

class KyoChon
{
public:
    void make_chicken()
    {
        int n;
        cout << "닭을 기름에 넣는다. \n";
        for (n = 5; n >= 1; n--)
        {
            cout << "닭을 " << n << "분간 더 튀깁니다. \n";
        }
        cout << "닭이 다 익었습니다. " << endl;
    }
};

class Padak
{
public:
    Padak();
    void make_chicken()
    {
        pd->make_chicken();
        cout << "파를 100그램 얹습니다." << endl;
    }

private:
    KyoChon *pd;
};

Padak::Padak()
{
    pd = new KyoChon();
}

int main()
{
    Padak p1;
    p1.make_chicken();

    return 0;
}

// CStack class에서 상속을 받아 데이터가 양수인 것만 받아들이는 CPositiveStack 을 만든다.

#include <iostream>
using namespace std;
class CStack
{
public:
    class node
    {
    public:
        int data;
        node *next;
        node(int x, node *nxt) : data(x), next(nxt) {}
    };
    CStack();
    void insert(int);
    int pop();
    void show();

protected:
    node *first;
};

CStack::CStack() { first = 0; }
void CStack::insert(int x)
{
    node *temp;
    temp = new node(x, first);
    temp->next = first;
    first = temp;
}
int CStack::pop()
{
    int retval;
    node *temp;
    if (first == 0)
        return -1;
    retval = first->data;
    temp = first;
    first = first->next;
    delete temp;
    return retval;
}

void CStack::show()
{
    node *temp;
    for (temp = first; temp; temp = temp->next)
        cout << temp->data << "--> ";
    cout << "END\n";
}

// class CPositiveStack 정의
class CPositiveStack : public CStack
{
public:
    void insert(int x)
    {
        if (x < 0)
            return;
        CStack::insert(x);
    }
};

int main()
{
    CStack s;
    CPositiveStack ps;
    s.insert(1);
    s.insert(2);
    s.insert(-3);
    s.insert(4);
    s.show();
    ps.insert(1);
    ps.insert(2);
    ps.insert(-3);
    ps.insert(4);
    ps.show();

    return 0;
}

// CStack class의 instance를 내부 변수(포인터)로 선언하여 데이터가 양수인 경우만 삽입하는 CPositiveStack

// CStack class에서 상속을 받아 데이터가 양수인 것만 받아들이는 CPositiveStack 을 만든다.

#include <iostream>
using namespace std;
class CStack
{
public:
    class node
    {
    public:
        int data;
        node *next;
        node(int x, node *nxt) : data(x), next(nxt) {}
    };
    CStack();
    void insert(int);
    int pop();
    void show();

protected:
    node *first;
};

CStack::CStack() { first = 0; }
void CStack::insert(int x)
{
    node *temp;
    temp = new node(x, first);
    temp->next = first;
    first = temp;
}
int CStack::pop()
{
    int retval;
    node *temp;
    if (first == 0)
        return -1;
    retval = first->data;
    temp = first;
    first = first->next;
    delete temp;
    return retval;
}

void CStack::show()
{
    node *temp;
    for (temp = first; temp; temp = temp->next)
        cout << temp->data << "--> ";
    cout << "END\n";
}

class CPositiveStack
{
public:
    CPositiveStack();
    void insert(int x)
    {
        if (x < 0)
            return;
        PS->insert(x);
    }
    void show()
    {
        PS->show();
    }
    void pop();

private:
    CStack *PS;
};

CPositiveStack::CPositiveStack()
{
    PS = new CStack();
}

int main()
{
    CStack s;
    CPositiveStack ps;
    s.insert(1);
    s.insert(2);
    s.insert(-3);
    s.insert(4);
    s.show();
    ps.insert(1);
    ps.insert(2);
    ps.insert(-3);
    ps.insert(4);
    ps.show();

    return 0;
}

// Day_11
//overloading

#include <iostream>
#include <stdio.h>
using namespace std;

int max(int x, int y)
{
    return (x > y) ? x : y;
}

float max(float x, float y)
{
    return (x > y) ? x : y;
}

int main()
{
    int result, i = 1, j = 2;
    float fresult, f1 = 1.5, f2 = 2.5;
    result = max(i, j);
    fresult = max(f1, f2);
    printf("%d\n", result);
    printf("%f\n", fresult);

    return 0;
}

//overloading => c++ 형태

#include <iostream>
#include <stdio.h>
using namespace std;

int max(int x, int y, int c)
{
    return max(max(x, y), c);
}

int max(int x, int y)
{
    return (x > y) ? x : y;
}

int main()
{
    int i, j, k;
    while (cin >> i >> j >> k)
    {
        cout << max(i, j, k) << endl;
    }

    return 0;
}

//Add String => operator

#include <iostream>
#include <string>
using namespace std;

string operator+(string s1, string s2)
{
    return s1.append(s2);
}

int main()
{
    string s1("Hello"), s2("world");
    cout << s1 + s2 << endl;
    return 0;
}

// 하나의 정수를 나타내기 위한 INT 클래스를 정의하고 함수 add를 정의하라

#include <iostream>
using namespace std;

class INT
{
public: // 생성자 2개 필요.
    INT() : m_data(0) {}
    INT(int i) : m_data(i) {}
    INT(int i, int j) { m_data = i + j; }
    int getValue() { return m_data; }

private:
    int m_data;
};
const INT add(INT a, INT b)
{
    INT temp(a.getValue(), b.getValue());
    // 생성자를 이용하여 덧셈을 한다.
    return temp; // temp를 반환한다.
}

int main()
{
    INT x(3), y(4), z;
    z = add(x, y);
    cout << z.getValue() << endl;
}

// 함수 add를 operator version 으로 바꾸고 테스트는 add(x,y) 대신 x + y 로 바꾼다.

#include <iostream>
using namespace std;

class INT
{
public:
    INT() : m_data(0) {}
    INT(int i) : m_data(i) {}
    int getValue() { return m_data; }

private:
    int m_data;
};
const INT operator+(INT a, INT b)
{
    return INT(a.getValue() + b.getValue());
}
const INT operator*(INT a, INT b)
{
    return INT(a.getValue() * b.getValue());
}

int main()
{
    INT x(3), y(4), a, m;
    a = x + y;
    cout << a.getValue() << endl;
    m = x * y;
    cout << m.getValue() << endl;
}

// method로 정의하기

#include <iostream>
using namespace std;

class INT
{
public: // 생성자 2개 필요.
    INT() : m_data(0) {}
    INT(int i) : m_data(i) {}
    int getValue() { return m_data; }
    const INT operator+(INT b)
    {
        return INT(this->m_data + b.m_data);
    }
    const INT operator*(INT b)
    {
        return INT(m_data * b.m_data);
    }

private:
    int m_data;
};

int main()
{
    INT x(3), y(4), z;
    z = x + y; // z = x.operator + (y)
    cout << z.getValue() << endl;
}

//unary operator를 이용해서 사각형의 폭을 1 증가시키는 전치 연산자 ++와 높이를 1씩 증가시키는 후위 연산자++를 정의

#include <iostream>
using namespace std;

class Rect
{
public:
    Rect(int w, int h) : m_width(w), m_height(h) {}
    const int operator*()
    {
        return m_width * m_height;
    }
    const int operator++()
    {
        return m_width++;
    }
    const int operator++(int n)
    {
        return m_height++;
    }

private:
    int m_width, m_height;
};

int main()
{
    Rect r(2, 3);
    r++; // 높이 증가
    cout << *r << endl;
    ++r; // 너비 증가
    cout << *r << endl;
    return 0;
}

// 배열의 범위를 체크하는 프로그램

#include <iostream>
using namespace std;

class LimitedArray
{
private:
    int data[100];
    int limit;

public:
    LimitedArray(int n) : limit(n) {}
    int &operator[](int n)
    {
        if (n >= limit)
        {
            cout << "Bounds error\n";
            return data[0];
        }
        return data[n];
    }
};

int main()
{
    LimitedArray a(5); // Array of size 5
    i = a[6];          // Bounds error
    i = a[3];          // Okay
    a[3] = 1;          // 현재는 불가능 하지만 배열은 시작주소를 포함하므로
                       // & 사용으로 Okay. l-value로 사용 가능
}

// cout.cpp

#include <stdio.h>
#include <iostream>

class COUT
{
public:
    void operator<<(int i)
    {
        printf("%d\n", i);
    }
};
int main()
{
    COUT cout;
    cout << 1;
    return 0;
}
